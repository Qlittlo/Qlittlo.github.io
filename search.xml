<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>公式测试</title>
      <link href="/2023/03/01/%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/03/01/%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>这是第一个公式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mn>1</mn><mn>2</mn><mn>3</mn></msubsup></mrow><annotation encoding="application/x-tex">1_2^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>这是第二个公式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∫</mo><mn>1</mn><mn>10</mn></msubsup><mi>x</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\int_1^{10}xdx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3648em;vertical-align:-0.3558em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0006em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.009em;"><span style="top:-2.3442em;margin-left:-0.1945em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.2579em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3558em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn><mspace linebreak="newline"></mspace><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1 + 1 = 2 \\ 1 + 2 = 3 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>K</mi><mi>P</mi><mi>I</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>S</mi><mo stretchy="false">)</mo><mi>W</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>P</mi><mi>I</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>N</mi><mo>+</mo><mi>S</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>I</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>W</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}KPI&amp;=(N+S)W \\PI&amp;=N+S \\I&amp;=W\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.5em;vertical-align:-2em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span><span style="top:-1.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>\begin{aligned} loss&=(y_i-Q(s,a;\theta))^2 \\&=(r+\gamma \max Q(s^{'},a^{'};\theta^{-})-Q(s,a;\theta)) ^2\\\end{aligned}$$ $y</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | 自定义数据类型</title>
      <link href="/2023/03/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/03/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="定义Sales-data类型">定义Sales_data类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该对象的定义，所以分号必不可少；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> &#123; <span class="comment">/* ... */</span> &#125; accum, trans, *salesptr;</span><br><span class="line"><span class="comment">// 与上一条语句等价，但可能更好一些</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line">Sales_data accum, trans, *salesptr;</span><br></pre></td></tr></table></figure><p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。例如，库类型string在名为string的头文件中定义。又如，我们应该把Sales_data类定义在名为Sales_data.h的头文件中。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | 引用</title>
      <link href="/2023/03/01/%E5%BC%95%E7%94%A8/"/>
      <url>/2023/03/01/%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是引用">什么是引用</h2><p>引用为对象起了另外一个名字，引用类型引用另外一种类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival;</span><br></pre></td></tr></table></figure><blockquote><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | 数组</title>
      <link href="/2023/03/01/%E6%95%B0%E7%BB%84/"/>
      <url>/2023/03/01/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组的大小确定不变，不能随意向数组中添加元素。</p><blockquote><p>如果不清楚元素的确切个数，使用vector</p></blockquote><h2 id="定义和初始化">定义和初始化</h2><p>数组的声明形如 a[d]，其中a是数组的名字，d是数组的维度，其中数组的维度d<strong>必须</strong>是<strong>常量表达式</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> cnt = <span class="number">42</span>;              <span class="comment">// 不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> sz = <span class="number">42</span>;     <span class="comment">// 常量表达式，关于constexpr</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];                    <span class="comment">// 含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *parr[sz];                  <span class="comment">// 含有42个整型指针的数组</span></span><br><span class="line">string bad[cnt];                <span class="comment">// 错误：cnt不是常量表达式</span></span><br><span class="line">string strs[<span class="built_in">get_size</span>()];        <span class="comment">// 当get_size是constexpr时正确；否则错误</span></span><br></pre></td></tr></table></figure><h2 id="不允许拷贝和赋值">不允许拷贝和赋值</h2><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;    </span><br><span class="line"><span class="type">int</span> a2[] = a;           <span class="comment">// 错误</span></span><br><span class="line">a2 = a;                 <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><blockquote><p>一些编译器支持数组的赋值，这就是所谓的编译器拓展。</p></blockquote><h2 id="复杂数组的声明">复杂数组的声明</h2><p>要理解数组声明的含义，最好的办法是<strong>从数组的名字开始按照由内向外的顺序阅读</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>];              <span class="comment">// ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="type">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ? */</span>;    <span class="comment">// 错误，不存在引用的数组</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;   <span class="comment">// Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;    <span class="comment">// arrRef引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure><h2 id="访问数组元素">访问数组元素</h2><p>与标准库类型vector与string一样。</p><h2 id="指针与数组">指针与数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string nums[] = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line">string *p = &amp;nums[<span class="number">0</span>];    <span class="comment">// p指向num的第一个元素</span></span><br><span class="line">string *p2 = nums;       <span class="comment">// 如上</span></span><br></pre></td></tr></table></figure><h2 id="标准库函数begin和end">标准库函数begin和end</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> *beg = <span class="built_in">begin</span>(ia);   <span class="comment">// 指向ia首元素的指针</span></span><br><span class="line"><span class="type">int</span> *last = <span class="built_in">end</span>(ia);    <span class="comment">// 指向ia尾元素的下一个位置的指针</span></span><br></pre></td></tr></table></figure><h2 id="解引用和指针运算的交互">解引用和指针运算的交互</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span> last = *(ia + <span class="number">4</span>);       <span class="comment">// 把last初始化成8，也就是ia[4]的值；</span></span><br><span class="line">last = *ia + <span class="number">4</span>;             <span class="comment">// 等价于last = ia[0] + 4;</span></span><br></pre></td></tr></table></figure><h2 id="使用数组初始化vector对象">使用数组初始化vector对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | 声明与定义</title>
      <link href="/2023/03/01/%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89/"/>
      <url>/2023/03/01/%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>一个文件的代码使用另一个文件中定义的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i;           <span class="comment">//声明i而非定义i</span></span><br><span class="line"><span class="type">int</span> j                   <span class="comment">//声明并定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">double</span> pi = <span class="number">3.14</span> <span class="comment">//定义</span></span><br></pre></td></tr></table></figure><blockquote><p>如果要在多个文件中使用同一个变量，就必须将声明和定义分离。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | 迭代器</title>
      <link href="/2023/03/01/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2023/03/01/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>迭代器有有效和无效之分，这一点和指针差不多。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置，其它情况都属于无效</p><h2 id="使用迭代器">使用迭代器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b表示v的第一个元素，e表示v尾元素的下一位置</span></span><br><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(), e = v.<span class="built_in">end</span>();    <span class="comment">// b和e的类型相同</span></span><br></pre></td></tr></table></figure><p>end成员则负责返回指向容器(或string对象)“尾元素的下一位置(one past the end)”的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“尾后( off the end)”元素。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。end成员返回的迭代器常被称作尾后迭代器( off-the-end iterator) 或者简称为尾迭代器(end iterator)。 特殊情况下如果容器为空，则begin和end返回的是同一个迭代器。</p><h2 id="迭代运算符">迭代运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*iter           <span class="comment">// 返回迭代器iter所指无素的引用</span></span><br><span class="line">iter- &gt;mem      <span class="comment">// 解引用iter并获取该元素的名为mem的成员，等价于(*iter) . mem</span></span><br><span class="line">++iter          <span class="comment">// 令iter指示容器中的下一个元素</span></span><br><span class="line">--iter          <span class="comment">// 令iter指示容器中的上一个元素</span></span><br><span class="line">iterl == iter2  <span class="comment">// 判断两个迭代器是否相等(不相等)，如果两个迭代器指示的是同一个元</span></span><br><span class="line">iter1 != iter2  <span class="comment">// 素或者它们是同一个容器的尾后迭代器，则相等;反之，不相等</span></span><br></pre></td></tr></table></figure><p>例：将string对象第一个字母改为大写形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">begin</span>() != s.<span class="built_in">end</span>())   <span class="comment">// 确保s非空</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将迭代器从一个元素移动到另外一个元素">将迭代器从一个元素移动到另外一个元素</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依次处理s的字符直至我们处理完全部字符或者遇到空白</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>() &amp;&amp; != <span class="built_in">isspace</span>(*it); ++it)</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br></pre></td></tr></table></figure><h2 id="迭代器类型">迭代器类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;           <span class="comment">// 能读能写</span></span><br><span class="line">string::iterator it2;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;    <span class="comment">// 只能读，不能写</span></span><br><span class="line">string::const_iterator it4;</span><br></pre></td></tr></table></figure><h2 id="begin和end运算符">begin和end运算符</h2><p>cbegin与cend</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();   <span class="comment">// it1是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = v.<span class="built_in">begin</span>();   <span class="comment">// it2是vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>();  <span class="comment">// 使用cbegin()无论vector对象本身是否是常量，返回值都是const_iterator</span></span><br></pre></td></tr></table></figure><h2 id="结合解引用和成员访问的操作">结合解引用和成员访问的操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种操作等价</span></span><br><span class="line">(*it).<span class="built_in">empty</span>()</span><br><span class="line">it-&gt;<span class="built_in">empty</span>()</span><br></pre></td></tr></table></figure><blockquote><p>但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</p></blockquote><h2 id="迭代器运算">迭代器运算</h2><p>例：二分搜索</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// text 必须有序</span></span><br><span class="line"><span class="comment">// beg 和 end 表示我们搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">begin</span>(), end = text.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = text.<span class="built_in">begin</span>() + (end - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; *mid != sought)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sought &lt; *mid)</span><br><span class="line">        end = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        beg = mid + <span class="number">1</span>;</span><br><span class="line">    mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | 处理类型</title>
      <link href="/2023/03/01/%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/03/01/%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="类型别名">类型别名</h2><p><strong>类型别名</strong>是一个名字，它是某种类型的同义词</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;       <span class="comment">// wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;     <span class="comment">// base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure><p>新标准规定了一种新的方法，使用<strong>别名声明</strong>来定义类型的别名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item;  <span class="comment">// SI是Sales_item的同义词</span></span><br></pre></td></tr></table></figure><h2 id="指针、常量和类型别名">指针、常量和类型别名</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// cstr是指向char的常量指针</span></span><br><span class="line"><span class="type">const</span> pstring *ps;      <span class="comment">// ps是一个指针，它的对象是指向char的常量指针</span></span><br></pre></td></tr></table></figure><p>注：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *cstr = <span class="number">0</span>;   <span class="comment">// 是对const pstring cstr的错误理解</span></span><br></pre></td></tr></table></figure><h2 id="auto类型说明符">auto类型说明符</h2><p>auto类型说明符，可以让编译器替我们去分析表达式所属的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;    <span class="comment">// item初始化为val1与val2相加的结果。</span></span><br></pre></td></tr></table></figure><p>auto一般会忽略掉顶层const，同时底层const则会保留下来，比如初始值是一个指向常量的指针时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;        <span class="comment">// b是一个整数</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;        <span class="comment">// c是一个整数</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;        <span class="comment">// d是一个整型指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;       <span class="comment">// e是一个指向整数常量的指针</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">// ci的推演类型是int，f是const int</span></span><br></pre></td></tr></table></figure><h2 id="decltype类型指示符">decltype类型指示符</h2><p>从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;  <span class="comment">// sum的类型就是函数f的返回类型</span></span><br></pre></td></tr></table></figure><p>decltype处理顶层const和引用的方式与auto有些许不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;         <span class="comment">// x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;         <span class="comment">// y的类型是const int&amp;，y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;             <span class="comment">// 错误：z是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure><p>如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decltype的结果可以是引用类型</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;      <span class="comment">// 正确：加法的结果是int，因此b是一个（未初始化的）int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;         <span class="comment">// 错误，c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure><p>因为r是一个引用，因此decltype®的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。</p><p>另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype (*p)的结果类型就是int&amp;，而非int。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((i)) d;    <span class="comment">// 错误；d是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;      <span class="comment">// 正确，e是一个（未初始化的）int</span></span><br></pre></td></tr></table></figure><blockquote><p>切记：decltype((variable))（注意是双层括号）的结果永远是引用，而decltype(variable)结果只有当variable本身是就是一个引用时才是一个引用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | 初始化</title>
      <link href="/2023/03/01/%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2023/03/01/%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化与赋值的区别">初始化与赋值的区别</h2><p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来代替。</p><h2 id="常见初始化方法">常见初始化方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> units_sold&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="默认初始化">默认初始化</h2><p>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0，定义在函数体内部的内置类型变量将<strong>不被初始化</strong></p><blockquote><p>建议初始化每一个内置类型的变量。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | 常量表达式</title>
      <link href="/2023/03/01/%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2023/03/01/%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义">定义</h2><p>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>;           <span class="comment">// max_files是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>;    <span class="comment">// limit是常量表达式</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;                <span class="comment">// staff_size不是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();          <span class="comment">// sz不是常量表达式</span></span><br></pre></td></tr></table></figure><h2 id="constexpr">constexpr</h2><p>C++新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。</p><blockquote><p>一般来说，如果认为一个变量是一个常量表达式，那就把它声明成constexpr类型。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | 表达式基础</title>
      <link href="/2023/03/01/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/03/01/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><p>C++定义了一元运算符(unary operator)和二元运算符(binary operator)。作用于一个运算对象的运算符是一元运算符，如取地址符(&amp;) 和解引用符(<em>);作用于两个运算对象的运算符是二元运算符，如相等运算符(==)和乘法运算符(</em>)。 除此之外，还有一个作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p><h2 id="递增与递减运算符">递增与递减运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">j = ++i;        <span class="comment">// j = 1, i = 1; 前置版本 得到递增后的值</span></span><br><span class="line">j = i++;        <span class="comment">// j = 1, i = 2; 后置版本 得到递增前的值</span></span><br></pre></td></tr></table></figure><blockquote><p>建议：除非必须，否则不用递增递减运算符的后置版本</p></blockquote><p>PS： *pbeg++等价于*(pbeg++)</p><h2 id="条件运算符">条件运算符</h2><p><strong>cond? expr1: expr2;</strong></p><p>其中cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。条件运算符的执行过程是:首先求cond的值，如果条件为真对expr1求值并返回该值，否则对expr2 求值并返回该值。举个例子，我们可以使用条件运算符判断成绩是否合格:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string finalgrade = (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br></pre></td></tr></table></figure><p>通过嵌套可以分为三级</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finalgrade = (grade &gt; <span class="number">90</span>) ? <span class="string">&quot;high pass&quot;</span> : (grade &lt; <span class="number">60</span>) ? <span class="string">&quot;fail&quot;</span> : <span class="string">&quot;pass&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | vector类型</title>
      <link href="/2023/03/01/vector%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/03/01/vector%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>标准库类型vector表示对象的集合，其中所有对象的类型都相同。</p><h2 id="引入">引入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespcae std;</span><br></pre></td></tr></table></figure><blockquote><p>vector 是模板而非类型，由vector生成的类型必须包含vector中元素的类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;               <span class="comment">// ivec保存int类型的对象</span></span><br><span class="line">vector&lt;Sales_item&gt; Sales_vec;   <span class="comment">// 保存Sales_item类型的对象</span></span><br></pre></td></tr></table></figure><blockquote><p>某些编译器可能需要vector&lt;vector&lt;int&gt; &gt;来定义vector的元素还是vector的场景。</p></blockquote><h2 id="定义和初始化vector对象">定义和初始化vector对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; v1;</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;</span><br><span class="line">vector&lt;T&gt; v2 = v1;</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v3</span><span class="params">(n, val)</span></span>;</span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v4</span><span class="params">(n)</span></span>;</span><br><span class="line">vector&lt;T&gt; v5&#123;a, b, c...&#125;;</span><br><span class="line">vector&lt;T&gt; v5 = &#123;a, b, c...&#125;</span><br></pre></td></tr></table></figure><p>C++新标准：列表初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; articles = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="列表初始值还是元素数量">列表初始值还是元素数量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// v1有10个元素，每个元素都是0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;     <span class="comment">// v2有1个元素，该元素都是10</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;  <span class="comment">// v3有10个元素，每个值都是1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4&#123;<span class="number">10</span>, <span class="number">1</span>&#125;;  <span class="comment">// v4有2个元素，值分别是10和1</span></span><br></pre></td></tr></table></figure><h2 id="向vector对象中添加元素">向vector对象中添加元素</h2><p>创建一个数组包含的元素是从0到99。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i)</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i)</span><br></pre></td></tr></table></figure><h2 id="其他vector操作">其他vector操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">empty</span>()           <span class="comment">// 如果v不含有任何元素，返回真:否则返回假</span></span><br><span class="line">v.<span class="built_in">size</span>()            <span class="comment">// 返回v中元素的个数</span></span><br><span class="line">v.<span class="built_in">push_back</span>(t)      <span class="comment">// 向v的尾端添加一个值为t的元素</span></span><br><span class="line">v[n]                <span class="comment">// 返回v中第n个位置上元素的引用</span></span><br><span class="line">v1 = v2             <span class="comment">// 用v2中元素的拷贝替换v1中的元素</span></span><br><span class="line">vl = &#123;a,b,c... &#125;    <span class="comment">// 用列表中元素的拷贝替换v1中的元素</span></span><br><span class="line">v1 == v2            <span class="comment">// v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同</span></span><br><span class="line">v1 != v2</span><br><span class="line">&lt;，&lt;=, &gt;，&gt;=        <span class="comment">// 顾名思义，以字典顺序进行比较</span></span><br></pre></td></tr></table></figure><p>将列表中元素进行平方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)</span><br><span class="line">    i *= i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><blockquote><p>要使用size_type，需首先指定他是由哪种类型定义的。vector对象的类型总是包含着元素的类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::size_type  <span class="comment">// 正确</span></span><br><span class="line">vector::size_type       <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>vector对象（以及string）的下注运算符可用于访问已存在的元素，而不能用于添加元素。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | string类型</title>
      <link href="/2023/03/01/string%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/03/01/string%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="引入">引入</h2><p>使用string类型必须首先包含string头文件，同时作为标准库的一部分，string定义在命名空间std中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h2 id="定义与初始化">定义与初始化</h2><p>分为<strong>直接初始化</strong>与<strong>拷贝初始化</strong>顾名思义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">string s2 = s1;</span><br><span class="line">string s3 = <span class="string">&quot;hiya&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>)</span></span>; <span class="comment">//10个c</span></span><br></pre></td></tr></table></figure><h2 id="读取位置数量的string对象">读取位置数量的string对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">        cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用getline读取一整行">使用getline读取一整行</h2><p>getline()函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来），然后把所读的内容存入到那个string对象中去（注意不存换行符）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="string的empty和size操作">string的empty和size操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line.<span class="built_in">empty</span>();   <span class="comment">// 判断line是否为空</span></span><br><span class="line">line.<span class="built_in">size</span>();    <span class="comment">// 返回line的长度</span></span><br></pre></td></tr></table></figure><h2 id="size-type类型">size_type类型</h2><p>size()函数返回的<strong>不是</strong>int<strong>而是</strong>string::size_type类型的值。</p><p>在C++11新标准中允许编译器通过auto或者decltype来推断变量的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = line.<span class="built_in">size</span>();     <span class="comment">// len的类型是string::size_type</span></span><br></pre></td></tr></table></figure><p>由于size函数返回的是一个无符号整型数，因此切记，如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。</p><h2 id="比较string对象">比较string对象</h2><p>原则：</p><ol><li>如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。</li><li>如果两个string对象在某些对应的位置上不一-致， 则string对象比较的结果其实是string对象中第- - 对相异字符比较的结果。</li></ol><h2 id="字面值与string对象相加">字面值与string对象相加</h2><p>当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象<strong>至少有一个</strong>是string</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>; s2 = <span class="string">&quot;world&quot;</span></span><br><span class="line">string s4 = s1 + <span class="string">&quot;, &quot;</span>;              <span class="comment">//正确</span></span><br><span class="line">string s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span>;         <span class="comment">//错误</span></span><br><span class="line">string s6 = s1 + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;world&quot;</span>;    <span class="comment">//正确：等价于(s1 + &quot;, &quot;) + &quot;world&quot;</span></span><br><span class="line">string s7 = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;, &quot;</span> + s2;    <span class="comment">//错误：不能将字面值直接相加</span></span><br></pre></td></tr></table></figure><blockquote><p>字符串字面值与string是不同的类型。</p></blockquote><h2 id="处理string对象中的字符">处理string对象中的字符</h2><p>使用cctype头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isalnum</span>(c)      <span class="comment">// 当c是字母或数字时为真</span></span><br><span class="line"><span class="built_in">isalpha</span>(c)      <span class="comment">// 当c是字母时为真</span></span><br><span class="line"><span class="built_in">iscntrl</span>(c)      <span class="comment">// 当c是控制字符时为真</span></span><br><span class="line"><span class="built_in">isdigit</span>(c)      <span class="comment">// 当c是数字时为真</span></span><br><span class="line"><span class="built_in">isgraph</span>(c)      <span class="comment">// 当c不是空格但可打印时为真</span></span><br><span class="line"><span class="built_in">islower</span>(c)      <span class="comment">// 当c是小写字母时为真</span></span><br><span class="line"><span class="built_in">isprint</span>(c)      <span class="comment">// 当c是可打印字符时为真(即c是空格或c具有可视形式)</span></span><br><span class="line"><span class="built_in">ispunct</span>(c)      <span class="comment">// 当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白的一种）</span></span><br><span class="line"><span class="built_in">isspace</span>(C)      <span class="comment">// 当c是空白时为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种)</span></span><br><span class="line"><span class="built_in">isupper</span>(c)      <span class="comment">// 当c是大写字母时为真</span></span><br><span class="line"><span class="built_in">isxdigit</span>(c)     <span class="comment">// 当c是十六进制数字时为真</span></span><br><span class="line"><span class="built_in">tolower</span>(c)      <span class="comment">// 如果c是大写字母，输出对应的小写字母:否则原样输出c</span></span><br><span class="line"><span class="built_in">toupper</span>(c)      <span class="comment">// 如果c是小写字母，输出对应的大写字母:否则原样输出c</span></span><br></pre></td></tr></table></figure><h2 id="处理每个字符">处理每个字符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>如果要想改变string对象中字符的值，必须把循环变量定义成引用类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello World!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="只处理一部分字符">只处理一部分字符</h2><p>要想访问string对象中的单个字符有两种方式：</p><ul><li>使用下标</li><li>使用迭代器</li></ul><h3 id="使用下标">使用下标</h3><p>将首字母大写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">    s[<span class="number">0</span>] = <span class="built_in">toupper</span>(s[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>把第一个词改为大写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) index = <span class="number">0</span>;</span><br><span class="line">    index != s.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isspace</span>(s[index]); ++index)</span><br><span class="line">        s[index] = <span class="built_in">toupper</span>(s[index]);</span><br></pre></td></tr></table></figure><blockquote><p>&amp;&amp;：逻辑与运算符</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ | const限定符</title>
      <link href="/2023/03/01/const%E9%99%90%E5%AE%9A%E7%AC%A6/"/>
      <url>/2023/03/01/const%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>我们想定义一种变量，它的值不能被改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>;</span><br></pre></td></tr></table></figure><p>const对象一旦创建后，其值就不能再改变，所以const对象必须初始化。</p><h2 id="如何跨文件">如何跨文件</h2><p>file_1.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();   <span class="comment">// 定义并初始化</span></span><br></pre></td></tr></table></figure><p>file_1.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;   </span><br></pre></td></tr></table></figure><blockquote><p>如果想在多个文件间共享const对象，必须在变量的定义之前添加extern关键字。</p></blockquote><h2 id="const的引用">const的引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci; <span class="comment">// 正确：引用及其对应的对象都是常量；</span></span><br><span class="line">r1 = <span class="number">42</span>             <span class="comment">// 错误：r1是对变量的引用</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci        <span class="comment">// 错误：试图让一个非变量引用指向一个常量对象</span></span><br></pre></td></tr></table></figure><blockquote><p>常量引用是对const的引用</p></blockquote><h2 id="const-指针">const 指针</h2><p>允许将指针本身定为常量即<strong>常量指针</strong>，常量指针必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb;   <span class="comment">// curErr将一直指向errNumb</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi;  <span class="comment">// pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure><blockquote><p>要想弄清楚这些声明的含义最行之有效的办法是从右往左阅读。</p></blockquote><h2 id="顶层const">顶层const</h2><p>因为指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。</p><p>用名词<strong>顶层 const</strong>表示指针<strong>本身</strong>是一个常量，而用名词<strong>底层 const</strong>表示指针<strong>指的对象</strong>是一个常量。</p><p>注：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2;   <span class="comment">// 靠右的是const是顶层const，靠左的是底层const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci;          <span class="comment">// 用于声明引用的const都是底层const</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArchLinux初始化配置</title>
      <link href="/2023/02/28/ArchLinux%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/02/28/ArchLinux%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装zsh">安装zsh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S zsh</span><br></pre></td></tr></table></figure><h2 id="添加新用户">添加新用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -G wheel -s /bin/zsh username</span><br></pre></td></tr></table></figure><h2 id="安装KDE桌面">安装KDE桌面</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S plasma konsole dolphin latte-dock</span><br></pre></td></tr></table></figure><h2 id="配置archlinuxcn镜像源">配置archlinuxcn镜像源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>之后安装 <code>archlinuxcn-keyring</code> 包导入 GPG key。</p><p>同时打开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Color</span><br><span class="line">TotalDownload</span><br><span class="line">CheckSpace</span><br><span class="line">VerbosePKgLists</span><br><span class="line"></span><br><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><h2 id="输入法">输入法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im</span><br><span class="line">sudo pacman -S fcitx5-chinese-addons</span><br></pre></td></tr></table></figure><p>编辑**~/.xprofile**</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure><h2 id="字体">字体</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji </span><br></pre></td></tr></table></figure><h2 id="配置yay">配置yay</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S yay</span><br></pre></td></tr></table></figure><h2 id="安装zsh-2">安装zsh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>或者直接pacman</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S oh-my-zsh-git</span><br></pre></td></tr></table></figure><p>高亮插件：<strong>zsh-syntax-highlighting</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure><p>建议插件：<strong>zsh-autosuggestions</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br></pre></td></tr></table></figure><h2 id="双系统同步时间">双系统同步时间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo timedatectl set-local-rtc true</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><h1>KDE</h1><h2 id="全局菜单">全局菜单</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S appmenu-gtk-module</span><br><span class="line">sudo pacman -S libdbusmenu-glib</span><br></pre></td></tr></table></figure><h2 id="截图软件">截图软件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S flameshot</span><br></pre></td></tr></table></figure><h2 id="KDE-Connect">KDE Connect</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S kdeconnect</span><br></pre></td></tr></table></figure><h2 id="预览功能增强">预览功能增强</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S ffmpegthumbs kdegraphics-thumbnailers(文档)</span><br></pre></td></tr></table></figure><h2 id="鼠标和触摸板">鼠标和触摸板</h2><p>setting里进行设置</p><h1>常用软件</h1><h2 id="通讯">通讯</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman qq-linux deepin.com.qq.office telegram-desktop</span><br></pre></td></tr></table></figure><h2 id="浏览器">浏览器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure><h2 id="音乐视频">音乐视频</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S spotify mpv netease-cloud-music</span><br></pre></td></tr></table></figure><h2 id="科学">科学</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S v2ray qv2ray</span><br></pre></td></tr></table></figure><h2 id="百度云">百度云</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S baidunetdisk-bin</span><br></pre></td></tr></table></figure><h1>生产工具</h1><h2 id="Visual-Studio-Code">Visual Studio Code</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S visual-studio-code-bin</span><br></pre></td></tr></table></figure><h2 id="Miniconda">Miniconda</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yay -S miniconda</span><br><span class="line">// 加入环境变量</span><br><span class="line">[ -f /opt/miniconda3/etc/profile.d/conda.sh ] &amp;&amp; source /opt/miniconda3/etc/profile.d/conda.sh</span><br></pre></td></tr></table></figure><h2 id="Python">Python</h2><p>使用虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装pip</span></span><br><span class="line">sudo pacman -S python-pip</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改pip源</span></span><br><span class="line">vim ~/.pip/pip.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入</span></span><br><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装virtualenv</span></span><br><span class="line">pip3 install virtualenv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入环境变量</span></span><br><span class="line">vim ~/.zshrc # 使用zsh</span><br><span class="line">export PATH=/home/qlittle/.local/bin/:$PATH</span><br><span class="line">source ~/.zshrc # 立即生效</span><br></pre></td></tr></table></figure><h1>显卡驱动</h1><h2 id="采取只使用独显的方法">采取只使用独显的方法</h2><p>查看nvidia独显型号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -k | grep -A 2 -E “(VGA|3D)”</span><br></pre></td></tr></table></figure><p>下载显卡驱动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nvidia-lts</span><br></pre></td></tr></table></figure><p>编辑nvidia配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Section &quot;Module&quot;</span><br><span class="line">    Load &quot;modesetting&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Device&quot;</span><br><span class="line">    Identifier &quot;nvidia&quot;</span><br><span class="line">    Driver &quot;nvidia&quot;</span><br><span class="line">    BusID &quot;&lt;BusID for NVIDIA device here&gt;&quot;  修改相应的busID</span><br><span class="line">    Option &quot;AllowEmptyInitialConfiguration&quot;</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure><p>配置sddm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo vim /usr/share/sddm/scripts/Xsetup</span></span><br><span class="line">xrandr --setprovideroutputsource modesetting NVIDIA-0</span><br><span class="line">xrandr --auto</span><br></pre></td></tr></table></figure><p>重启</p><h1>游戏</h1><h2 id="HMCL">HMCL</h2><p>安装 hmcl 我的世界启动器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S hmcl</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫环境配置</title>
      <link href="/2023/02/28/%E7%88%AC%E8%99%AB%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/02/28/%E7%88%AC%E8%99%AB%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟环境配置">虚拟环境配置</h2><p>虚拟环境可以使项目所使用的库与默认的base进行隔离，更方便管理。</p><h3 id="pip换源">pip换源</h3><p>通过换源可以使pip安装库更加快速</p><p>在C:\Users\你的用户名\ 目录下创建pip文件夹</p><p>其目录大概这个样子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Qlittle\pip</span><br></pre></td></tr></table></figure><p>进入pip文件夹，创建一个名为 <strong>pip.ini</strong> 的文件<br>用VS Code或者记事本打开进行编辑，注意修改下cache-dir，这里是下载缓存，你自己改成你自己想放在的地方，挺大的不建议放在C盘。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">timeout</span> = <span class="number">6000</span></span><br><span class="line"><span class="attr">index-url</span> = https://mirrors.bfsu.edu.cn/pypi/web/simple</span><br><span class="line"><span class="attr">cache-dir</span> = D:\\Cache\\pip</span><br></pre></td></tr></table></figure><h3 id="检查python库">检查python库</h3><p>打开终端，这里使用的是PowerShell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure><p>检查是否有<strong>virtualenv</strong><br>若没有则进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure><h3 id="创建虚拟环境">创建虚拟环境</h3><blockquote><p>shell命令前为当前目录。即一下格式为：当前目录&gt; shell命令</p></blockquote><ol><li><p>创建项目文件夹</p><p>在D盘的Code的目录下创建了一个名为<strong>ReqLearn</strong>的文件夹，并进入</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Code&gt; mkdir ReqLearn </span><br><span class="line">D:\Code&gt; cd .\ReqLearn\</span><br></pre></td></tr></table></figure></li><li><p>创建虚拟环境</p><p>创建虚拟环境并检查是否成功。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Code\ReqLearn&gt; virtualenv venv   # 这里的venv可以是任意名</span><br><span class="line">D:\Code\ReqLearn&gt; ls</span><br></pre></td></tr></table></figure><p>成功则在当前目录下创建一个venv的文件夹</p></li><li><p>激活虚拟环境</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\Code\ReqLearn&gt; cd .\venv\Scripts\</span><br><span class="line">D:\Code\ReqLearn\venv\Scripts&gt; .\activate</span><br></pre></td></tr></table></figure><p>这时你会发现命令行最前端会多出一个 <strong>(venv)</strong> 类似</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(venv) PS D:\Code\ReqLearn\venv\Scripts&gt;</span><br></pre></td></tr></table></figure><p>再次检查python库列表</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure><p>你会发现只有基础库，这便说明你是在虚拟环境的容器里。</p></li><li><p>安装爬虫常用库</p><p>还有一些什么 beautifulsoup scrapy，这里只安装了requests（请求库）与pymysql（数据库支持）</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests pymysql</span><br></pre></td></tr></table></figure><p>这时在运行 <strong>pip list</strong> 便可以看到有requests的标识</p></li><li><p>使用VS Code打开项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Code&gt; code .\ReqLearn\</span><br></pre></td></tr></table></figure><p>这时候VS Code就起来了</p></li></ol><h2 id="VS-Code-插件设置">VS Code 插件设置</h2><p>安装“Chinese ……”这个官方汉化插件与“python”的官方python支持插件就行。</p><h2 id="一个简单的爬虫">一个简单的爬虫</h2><h3 id="准备阶段">准备阶段</h3><p><a href="http://xn--demo-k84fui24cc14eklmvla.py">新建一个文件demo.py</a>，这时候右下角可能提示你是否安装一个库，先不要管，但不要关掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br></pre></td></tr></table></figure><p>点击运行（左上角的三角），看看下方终端是否报错，同时应该注意运行时是否自动进入了虚拟环境，也就是命令好前是否有(venv)。<br>以上都无误后，安装上面vscode提到的那个库，点击后其实就是运行了这条命令，安装了一个辅助检测Python代码是否规范的工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d:/Code/ReqLearn/venv/Scripts/python.exe -m pip install -U flake8</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql安装</title>
      <link href="/2023/02/28/Mysql%E5%AE%89%E8%A3%85/"/>
      <url>/2023/02/28/Mysql%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>以Ubuntu为例</p><h2 id="安装mysql-server">安装mysql-server</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update </span><br><span class="line">sudo apt upgrade // 更新</span><br><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></figure><h2 id="进行安装的初始化">进行安装的初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql_secure_installation </span><br></pre></td></tr></table></figure><p>按照提示选择即可</p><h2 id="验证是否安装成功">验证是否安装成功</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql --version // 查看版本</span><br><span class="line">sudo mysql -u root -p</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>标签</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>动画</title>
      <link href="/cartoon/index.html"/>
      <url>/cartoon/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }/* 全局宽度 */.layout {  max-width: 1400px;}/* 侧边卡片栏宽度 */.aside-content {  max-width: 318px;  min-width: 300px;}/* 平板尺寸自适应(不启用侧边栏宽度限制) */@media screen and (max-width: 900px) {  .aside-content {    max-width: none !important;    padding: 0 5px 0 5px;  }}/* 除了首页以外其他页面隐藏卡片，并采用宽屏显示 */#archive,#page,#category,#tag {  width: 100%;}.page:not(.page.home) .aside-content {  display: none;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}:root {  --trans-light: rgba(255, 255, 255, 0.88);  --trans-dark: rgba(25, 25, 25, 0.88);  --border-style: 1px solid rgb(169, 169, 169);  --backdrop-filter: blur(5px) saturate(150%);}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}/* 字体 */@font-face {  /* 为载入的字体取名字(随意) */  font-family: 'DEYI';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/deyi.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () {  if (document.hidden) {    //离开当前页面时标签显示内容    document.title = '👀 Where you are? ~';    clearTimeout(titleTime);  } else {    //返回当前页面时标签显示内容    document.title = '🐖 I find you!';    //两秒后变回正常标题    titleTime = setTimeout(function () {      document.title = OriginTitile;    }, 2000);  }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>壁纸</title>
      <link href="/wallpaper/index.html"/>
      <url>/wallpaper/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
